<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Habit Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Removed external game.css link, styles are inline -->
    <style>
        /* Base variables (adjust colors as desired) */
        :root {
            --background-primary: #121212;
            --background-secondary: #1a1a1a;
            --background-tertiary: #2a2a2a;
            --background-hover: #404040;
            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --accent-primary: #64b5f6; /* Light Blue */
            --accent-secondary: #ffab40; /* Orange */
            --color-success: #4caf50; /* Green */
            --color-warning: #ffc107; /* Yellow */
            --color-danger: #f44336; /* Red */
            --border-color: #444;
            --spacing-sm: 5px;
            --spacing-md: 10px;
            --spacing-lg: 15px;
            --radius-sm: 4px;
            --radius-md: 8px;
        }

        /* General Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-primary);
            color: var(--text-primary);
            margin: 0;
            padding: var(--spacing-lg);
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: var(--spacing-lg);
            background-color: var(--background-secondary);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        h1, h2, h3 {
            color: var(--accent-primary);
            margin-top: 0;
            margin-bottom: var(--spacing-lg);
        }
        h2 { margin-top: var(--spacing-lg); border-bottom: 1px solid var(--border-color); padding-bottom: var(--spacing-sm); }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 500;
            background-color: var(--accent-primary);
            color: #111;
            transition: background-color 0.2s ease;
        }
        button:hover:not(:disabled) { background-color: #82c7ff; }
        button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
        button.delete { background-color: var(--color-danger); color: white; }
        button.delete:hover:not(:disabled) { background-color: #ff6b60; }
        button.use-card { background-color: var(--color-success); color: white; }
        button.use-card:hover:not(:disabled) { background-color: #6fbf73; }

        input[type="text"], input[type="number"], textarea, select {
            background-color: var(--background-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 8px;
            width: 100%;
            box-sizing: border-box;
        }
        input::placeholder, textarea::placeholder { color: var(--text-secondary); }
        label { display: block; margin-bottom: var(--spacing-sm); font-size: 0.9em; color: var(--text-secondary); }

        ul { list-style: none; padding: 0; margin: 0; }
        li { margin-bottom: var(--spacing-md); }

        /* Section Styles */
        .section { margin: var(--spacing-lg) 0; padding: var(--spacing-lg); background: var(--background-secondary); border-radius: var(--radius-md); border: 1px solid var(--border-color); }
        .controls { margin-bottom: var(--spacing-md); display: flex; gap: var(--spacing-md); }

        /* Form Popup */
        .form-popup { background: var(--background-tertiary); padding: var(--spacing-lg); border-radius: var(--radius-sm); margin-top: var(--spacing-md); border: 1px solid var(--border-color); }
        .form-popup div { margin-bottom: var(--spacing-md); }
        .form-popup button:last-of-type { background-color: #555; } /* Style Close button */
        .form-popup button:last-of-type:hover:not(:disabled) { background-color: #777; }

        /* General Stats */
        .general-stats { text-align: center; margin-bottom: var(--spacing-lg); font-size: 1.1em; color: var(--text-secondary); }

        /* User Stats */
        #user-stats-list li { display: block; list-style: none; } /* Override flex if needed */
        .stat-card {
            background-color: var(--background-tertiary); padding: var(--spacing-md) var(--spacing-lg); border-radius: var(--radius-sm);
            border: 1px solid var(--border-color); margin-bottom: var(--spacing-sm); position: relative;
        }
        .delete-stat-btn { position: absolute; top: 5px; right: 5px; padding: 2px 6px; font-size: 0.8em; }
        .stat-level { font-weight: bold; color: var(--accent-secondary); }
        .stat-name { font-size: 1.1em; font-weight: 500; margin: 3px 0; }
        .stat-xp { font-size: 0.9em; color: var(--text-secondary); }
        .xp-bar { background-color: #555; height: 8px; border-radius: var(--radius-sm); overflow: hidden; margin-top: var(--spacing-sm); }
        .xp-bar-fill { background: linear-gradient(90deg, var(--color-success) 0%, var(--accent-primary) 100%); height: 100%; transition: width 0.3s ease; }

        /* Task Runner */
        .task-timer { text-align: center; }
        #timer-display { font-size: 2.5em; font-weight: bold; display: block; margin-bottom: var(--spacing-sm); }
        .timer-bar-container { background: #444; border-radius: 5px; overflow: hidden; margin: 5px 0 var(--spacing-md); }
        #timer-bar { height: 10px; width: 100%; background: linear-gradient(90deg, var(--color-success) 0%, var(--accent-primary) 100%); transition: width 0.1s linear; }
        #task-runner .controls button { margin: 0 var(--spacing-sm); }

        /* Penalty Display */
        .penalty-active { color: var(--color-warning); font-weight: bold; }

        /* Task List */
        #task-list li {
            background-color: var(--background-tertiary);
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            margin-bottom: var(--spacing-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .task-card-content { display: flex; justify-content: space-between; width: 100%; align-items: center; }
        .task-info { flex-grow: 1; margin-right: var(--spacing-lg); }
        .task-name { font-weight: bold; font-size: 1.1em; }
        .task-time, .task-best-time, .task-stat, .task-desc { font-size: 0.9em; color: var(--text-secondary); margin-top: 3px; }
        .task-desc { font-style: italic; }
        .task-actions { display: flex; gap: var(--spacing-sm); }
        .task-actions button { padding: 5px 10px; font-size: 1.2em; /* Make icons bigger */}

        /* Inventory List - Updated for Clickable Cards */
        #inventory-list {
            display: grid; /* Use grid for better layout */
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* Responsive columns */
            gap: var(--spacing-md);
        }
        #inventory-list li {
            display: block; /* Reset from flex if it was set */
            background-color: var(--background-tertiary);
            padding: var(--spacing-md);
            margin-bottom: 0; /* Handled by gap */
            border-radius: var(--radius-sm);
            border: 2px solid transparent; /* Base for selected state */
            position: relative; /* Needed for absolute positioning of status */
            transition: background-color 0.2s ease, transform 0.1s ease, border-color 0.2s ease;
        }
        #inventory-list li.clickable-card { cursor: pointer; }
        #inventory-list li.clickable-card:not(.disabled):hover {
            background-color: var(--background-hover);
            transform: translateY(-2px);
            border-color: #555; /* Subtle border hover */
        }
        #inventory-list li.clickable-card.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        #inventory-list li.clickable-card.selected-for-task {
            border-color: var(--accent-primary);
            /* background-color: #3a5a6a; Optional */
        }
        .card-container {
            display: flex;
            flex-direction: column; /* Stack icon and details vertically */
            align-items: center; /* Center items */
            text-align: center; /* Center text */
            width: 100%;
        }
        .card-icon { margin-bottom: var(--spacing-sm); font-size: 2em; } /* Larger icon */
        .card-details { flex-grow: 1; }
        .card-name { font-weight: 500; display: block; margin-bottom: 3px; }
        .card-desc { font-size: 0.85em; color: var(--text-secondary); }
        .card-status {
            position: absolute;
            top: 5px; right: 5px;
            font-size: 0.7em;
            background-color: var(--accent-primary);
            color: #111;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        #inventory-empty { text-align: center; color: var(--text-secondary); font-style: italic; grid-column: 1 / -1; /* Span all columns */}

        /* Reward Pool List */
        #reward-pool-list li {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px; background: var(--background-tertiary); margin-bottom: 5px; border-radius: var(--radius-sm);
        }
        #reward-pool-list li button { margin-left: var(--spacing-md); padding: 3px 8px; }
        #reward-pool-status { margin-top: var(--spacing-md); color: var(--text-secondary); }

        /* Store List */
        #lootbox-list { display: flex; gap: var(--spacing-lg); flex-wrap: wrap; }
        .lootbox-item {
            background: var(--background-tertiary);
            padding: var(--spacing-lg);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            flex-basis: 200px; /* Minimum width */
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center content */
            text-align: center;
        }
         .lootbox-item h3 { margin-bottom: var(--spacing-sm); color: var(--accent-secondary); }
         .lootbox-item p { margin-bottom: var(--spacing-md); color: var(--text-secondary); }
         .lootbox-item button { margin-top: auto; /* Push button to bottom */ padding: 5px 10px; width: 80%; }

        /* Modal Styles */
        .hidden { display: none !important; } /* Use important to override potential conflicts */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 1000;
            backdrop-filter: blur(3px);
        }
        .modal-content { background: var(--background-secondary); padding: 20px 30px; border-radius: var(--radius-md); min-width: 300px; max-width: 90%; border: 1px solid var(--border-color); box-shadow: 0 5px 20px rgba(0,0,0,0.4); }
        .modal-content h3 { margin-bottom: var(--spacing-lg); }
        #card-task-list button { width: 100%; margin-bottom: var(--spacing-sm); }
        #cancel-card-task-btn { background: #555; margin-top: var(--spacing-md); width: 100%; }
        #cancel-card-task-btn:hover { background: #777; }

        /* User Stats Flex Layout Override */
        #user-stats-list {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        #user-stats-list li {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Habit Challenge RPG - Balatro Style</h1>

        <div class="general-stats" id="general-stats-display">Coins: 0 | Base Stat XP: 15</div>

        <!-- User Stats Section -->
        <div id="user-stats-section" class="section">
            <h2>Character Stats</h2>
            <div class="section-content">
                <ul id="user-stats-list">
                     <!-- JS Populated -->
                     <li style="justify-content: center; color: var(--text-secondary); font-style: italic;">No stats created yet. Add one below.</li>
                </ul>
                <div style="margin-top: var(--spacing-lg); display: flex; gap: var(--spacing-md); align-items: flex-end;">
                     <div style="flex-grow: 1;">
                         <label for="new-stat-name">New Stat Name:</label>
                         <input type="text" id="new-stat-name" placeholder="e.g., Focus" style="width: 100%;">
                     </div>
                     <button id="add-stat-btn">Add Stat</button>
                </div>
            </div>
        </div>

        <!-- Task Runner Section (Initially Hidden) -->
        <div id="task-runner" class="section hidden">
            <h2 id="task-runner-name">Running Task...</h2>
            <div class="section-content">
                <div class="task-timer">
                    <span id="timer-display">00:00</span>
                    <div class="timer-bar-container">
                        <div id="timer-bar" class="timer-bar"></div>
                    </div>
                    <div class="controls" style="justify-content: center;">
                        <button id="complete-task-early-btn" class="use-card">Complete Task Now</button>
                        <button id="fail-task-btn" class="delete">Fail Task</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Active Penalty Section -->
        <div id="active-penalty-section" class="section hidden">
            <h2>Next Task Penalty</h2>
            <div class="section-content">
                <p id="active-penalty-display" class="penalty-active"></p>
            </div>
        </div>

        <!-- Task Management Section -->
        <div id="task-management" class="section">
            <h2>Manage Tasks</h2>
            <div class="section-content">
                <div class="controls">
                    <button id="show-add-task-popup">+ Add Task</button>
                </div>
        
                <div class="form-popup hidden" id="add-task-popup">
                    <h3>Create New Task</h3>
                     <div><label for="new-task-name">Task Name:</label><input type="text" id="new-task-name"></div>
                     <div><label for="new-task-time">Time (s):</label><input type="number" id="new-task-time" min="10" placeholder="Min 10s"></div>
                     <div><label for="new-task-stat">Assign Stat XP:</label><select id="new-task-stat"><option value="">None</option></select></div>
                     <div><label for="new-task-desc">Description:</label><textarea id="new-task-desc" placeholder="Optional details"></textarea></div>
                     <div><label for="new-task-xp">Base Stat XP:</label><input type="number" id="new-task-xp" placeholder="Optional, default: 15" min="0"></div>
                     <button id="add-task-btn">Add Task</button>
                     <button id="close-add-task-popup" type="button">Close</button>
                </div>
                <ul id="task-list">
                    <li style="justify-content: center; color: var(--text-secondary); font-style: italic;">No tasks added yet.</li>
                </ul>
            </div>
        </div>

        <!-- Inventory Section -->
        <div id="inventory-section" class="section">
            <h2>Reward Card Inventory</h2>
            <div class="section-content">
                <ul id="inventory-list">
                    <!-- JS Populated: Cards will appear here -->
                </ul>
                <p id="inventory-empty" class="hidden">Your inventory is empty.</p>
            </div>
        </div>

        <!-- Reward Pool Management -->

        <!-- Store Section -->
        <div id="store-section" class="section">
            <h2>Lootbox Store</h2>
            <div class="section-content">
                <div id="lootbox-list">
                     <!-- JS Populated -->
                    <p>Generate lootboxes from the Reward Pool section first.</p>
                </div>
            </div>
        </div>

        <div id="reward-pool-section" class="section">
            <h2>Reward Pool (Needs multiple of 3)</h2>
            <div class="section-content">
                <div class="controls">
                    <button id="show-add-reward-popup">+ Add Reward</button>
                    <button id="generate-lootboxes-btn" disabled>Generate Lootboxes</button>
                </div>
                <div class="form-popup hidden" id="add-reward-popup">
                    <h3>Add Custom Reward</h3>
                    <div>
                        <label for="new-reward-name">Reward Name:</label>
                        <input type="text" id="new-reward-name" placeholder="e.g., 15 Min Break">
                    </div>
                    <div>
                        <label for="new-reward-weight">Pleasurability (1=High Chance, 10=Low Chance):</label>
                        <input type="number" id="new-reward-weight" min="1" max="10" placeholder="1-10">
                    </div>
                    <button id="add-reward-btn">Add Reward to Pool</button>
                    <button id="close-add-reward-popup" type="button">Close</button>
                </div>
                <ul id="reward-pool-list">
                     <!-- JS Populated -->
                    <li style="justify-content: center; color: var(--text-secondary); font-style: italic;">Add rewards to the pool.</li>
                </ul>
                <p id="reward-pool-status">Pool empty. Add rewards.</p>
            </div>
        </div>
    </div> <!-- End Container -->

    <!-- Card Task Selection Modal -->
    <div id="card-task-modal" class="hidden modal-overlay">
      <div class="modal-content">
        <h3>Select a Task for this Card</h3>
        <div id="card-task-list" style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto;">
             <!-- Task buttons populated by JS -->
        </div>
        <button id="cancel-card-task-btn">Cancel</button>
      </div>
    </div>

    <script>
        class HabitGame {
            constructor() {
                // --- Audio Setup ---
                try {
                    this.hoverSound = new Audio('hover.mp3'); // Replace with actual paths if needed
                    this.hoverSound.volume = 0.5;
                    this.winSound = new Audio('win.mp3');
                    this.winSound.volume = 0.8;
                    this.loseSound = new Audio('lose.mp3');
                    this.loseSound.volume = 0.8;
                    this.timerSound = new Audio('timer.mp3');
                    this.timerSound.loop = true;
                    this.timerSound.volume = 0;
                    this.coinSound = new Audio('coin.mp3');
                    this.coinSound.volume = 0.7;
                    this.openBoxSound = new Audio('open_box.mp3');
                    this.openBoxSound.volume = 0.9;
                    this.burnSound = new Audio('burn.mp3');
                    this.burnSound.volume = 0.6;
                    // Preload attempt (optional)
                    this.hoverSound.load(); this.winSound.load(); this.loseSound.load(); this.timerSound.load(); this.coinSound.load(); this.openBoxSound.load(); this.burnSound.load();
                } catch (e) {
                    console.warn("Audio setup failed (maybe no audio support or files missing):", e);
                    // Create dummy audio objects so calls don't break
                    this.hoverSound = this.winSound = this.loseSound = this.timerSound = this.coinSound = this.openBoxSound = this.burnSound = { play: () => {}, pause: () => {}, load: () => {}, currentTime: 0, volume: 0 };
                }
                this.sectionVisibility = this.loadSectionVisibility();
                this.addSectionToggles();

                // --- DOM Elements ---
                this.dom = {
                    generalStatsDisplay: document.getElementById('general-stats-display'),
                    taskRunner: document.getElementById('task-runner'),
                    taskRunnerName: document.getElementById('task-runner-name'),
                    timerDisplay: document.getElementById('timer-display'),
                    timerBar: document.getElementById('timer-bar'),
                    completeTaskEarlyBtn: document.getElementById('complete-task-early-btn'),
                    failTaskBtn: document.getElementById('fail-task-btn'),
                    activePenaltySection: document.getElementById('active-penalty-section'),
                    activePenaltyDisplay: document.getElementById('active-penalty-display'),
                    taskManagement: document.getElementById('task-management'),
                    showAddTaskPopup: document.getElementById('show-add-task-popup'),
                    addTaskPopup: document.getElementById('add-task-popup'),
                    newTaskName: document.getElementById('new-task-name'),
                    newTaskTime: document.getElementById('new-task-time'),
                    newTaskStat: document.getElementById('new-task-stat'),
                    newTaskDesc: document.getElementById('new-task-desc'),
                    newTaskXp: document.getElementById('new-task-xp'),
                    addTaskBtn: document.getElementById('add-task-btn'),
                    closeAddTaskPopup: document.getElementById('close-add-task-popup'),
                    taskList: document.getElementById('task-list'),
                    inventorySection: document.getElementById('inventory-section'),
                    inventoryList: document.getElementById('inventory-list'),
                    inventoryEmpty: document.getElementById('inventory-empty'),
                    userStatsSection: document.getElementById('user-stats-section'),
                    userStatsList: document.getElementById('user-stats-list'),
                    newStatName: document.getElementById('new-stat-name'),
                    addStatBtn: document.getElementById('add-stat-btn'),
                    cardTaskModal: document.getElementById('card-task-modal'),
                    cardTaskList: document.getElementById('card-task-list'),
                    cancelCardTaskBtn: document.getElementById('cancel-card-task-btn'),
                    rewardPoolSection: document.getElementById('reward-pool-section'),
                    showAddRewardPopup: document.getElementById('show-add-reward-popup'),
                    addRewardPopup: document.getElementById('add-reward-popup'),
                    newRewardName: document.getElementById('new-reward-name'),
                    newRewardWeight: document.getElementById('new-reward-weight'),
                    addRewardBtn: document.getElementById('add-reward-btn'),
                    closeAddRewardPopup: document.getElementById('close-add-reward-popup'),
                    rewardPoolList: document.getElementById('reward-pool-list'),
                    rewardPoolStatus: document.getElementById('reward-pool-status'),
                    generateLootboxesBtn: document.getElementById('generate-lootboxes-btn'),
                    storeSection: document.getElementById('store-section'),
                    lootboxList: document.getElementById('lootbox-list'),
                };

                // --- Configuration ---
                this.config = {
                    baseXpPerTask: 15,
                    baseCoinsPerTask: 10,
                    statBaseXpForLevel2: 100,
                    statXpLevelMultiplier: 1.5,
                    lootboxBasePrice: 100, // Constant 'n'
                    rewardsPerLootbox: 3,
                    numberOfLootboxes: 3
                };

                // --- Game State ---
                this.state = {
                    tasks: [],
                    inventory: [],
                    generalStats: { coins: 0 },
                    userStats: [],
                    activePenalty: null,
                    activeTask: null,
                    cardToUseOnNext: {},
                    rewardPool: [],
                    lootboxes: [] // Generated, not saved
                };

                // Card & Penalty Definitions
                this.rewardCardTypes = [
                    { type: 'EXTRA_TIME_ACE', name: 'Extra Time Ace', emoji: '‚è∞', description: '+30s task time', effect: (limit) => limit + 30 },
                    { type: 'TIME_JACKPOT', name: 'Time Jackpot', emoji: 'üé∞', description: '+60s task time', effect: (limit) => limit + 60 },
                    { type: 'DOUBLE_XP', name: 'Double Down XP', emoji: '‚ú®', description: '2x Stat XP gain', multiplier: { xp: 2 } },
                    { type: 'DOUBLE_COINS', name: 'High Roller Coins', emoji: 'üí∞', description: '2x Coin gain', multiplier: { coins: 2 } },
                    { type: 'INSURANCE', name: 'Insurance Policy', emoji: 'üõ°Ô∏è', description: 'Negate failure penalty', special: 'insurance' },
                    { type: 'TRIPLE_XP', name: 'Triple Threat XP', emoji: 'üî•', description: '3x Stat XP gain', multiplier: { xp: 3 } },
                    { type: 'COIN_MAGNET', name: 'Coin Magnet', emoji: 'üß≤', description: '1.5x Coin gain', multiplier: { coins: 1.5 } },
                    //{ type: 'TIME_REWIND', name: 'Time Rewind', emoji: '‚è™', description: 'Adds 15s < 10s left', special: 'timeRewind' }, // Complex logic needed in timer
                    { type: 'LUCKY_STREAK', name: 'Lucky Streak', emoji: 'üçÄ', description: '25% chance 2x rewards', special: 'luckyStreak' },
                    //{ type: 'COMBO_CHAIN', name: 'Combo Chain', emoji: 'üîó', description: 'Next card effect x2', special: 'comboChain' }, // Complex logic
                ];
                this.penaltyTypes = [
                    { type: 'BAD_BEAT', name: 'Bad Beat', emoji: 'üí•', description: 'Lose random card', immediate: true },
                    { type: 'LET_IT_RIDE', name: 'Let It Ride', emoji: 'üîÑ', description: 'Retry task immediately', immediate: true },
                    { type: 'TIME_CRUNCH', name: 'Time Crunch', emoji: '‚è≥', description: 'Next task -25% time', nextTask: true, effect: (limit) => limit * 0.75 },
                    { type: 'BEAT_THE_CLOCK', name: 'Beat The Clock', emoji: '‚è±Ô∏è', description: 'Next task -15s', nextTask: true, effect: (limit) => Math.max(10, limit - 15) },
                    { type: 'HALF_COINS', name: 'Half Coins', emoji: 'ü™ô', description: 'Next task -50% coins', nextTask: true, penaltyMultiplier: { coins: 0.5 } },
                    { type: 'XP_DRAIN', name: 'XP Drain', emoji: 'ü©∏', description: 'Next task -50% Stat XP', nextTask: true, penaltyMultiplier: { xp: 0.5 } },
                    { type: 'TIME_BOMB', name: 'Time Bomb', emoji: 'üí£', description: 'Next task -20% time', nextTask: true, effect: (limit) => limit * 0.8 },
                    { type: 'CURSE_OF_DOUBT', name: 'Curse of Doubt', emoji: 'üßø', description: 'Next task 25% chance 0 rewards', nextTask: true, special: 'curseOfDoubt' },
                    { type: 'DOUBLE_TROUBLE', name: 'Double Trouble', emoji: '‚ö†Ô∏è', description: 'Next penalty effect doubled', nextTask: true, special: 'doubleTrouble' },
                ];

                // --- Initialization ---
                this.loadState();
                this.loadLootboxes();
                this.bindEvents();
                this.render();
            }

            // --- State Management ---
            loadState() {
                console.log("Loading state...");
                const savedState = localStorage.getItem('habitGameState_v2');
                if (savedState) {
                    try {
                        const parsed = JSON.parse(savedState);
                        this.state.tasks = Array.isArray(parsed.tasks) ? parsed.tasks : [];
                        this.state.inventory = Array.isArray(parsed.inventory) ? parsed.inventory : [];
                        this.state.generalStats = typeof parsed.generalStats === 'object' && parsed.generalStats !== null ? parsed.generalStats : { coins: 0 };
                        this.state.userStats = Array.isArray(parsed.userStats) ? parsed.userStats : [];
                        this.state.activePenalty = typeof parsed.activePenalty === 'object' ? parsed.activePenalty : null;
                        this.state.cardToUseOnNext = typeof parsed.cardToUseOnNext === 'object' && parsed.cardToUseOnNext !== null ? parsed.cardToUseOnNext : {};
                        this.state.rewardPool = Array.isArray(parsed.rewardPool) ? parsed.rewardPool : [];
                        console.log("State loaded successfully.");
                    } catch (e) {
                         console.error("Failed to parse saved state:", e);
                         // Reset to defaults if parsing fails
                         this.state = { tasks: [], inventory: [], generalStats: { coins: 0 }, userStats: [], activePenalty: null, activeTask: null, cardToUseOnNext: {}, rewardPool: [], lootboxes: [] };
                    }
                } else {
                    console.log("No saved state found, using defaults.");
                }

                // Ensure numeric types & calculations post-load
                this.state.tasks.forEach(t => {
                    t.baseTime = Number(t.baseTime || 10); // Ensure minimum time
                    t.bestTime = t.bestTime ? Number(t.bestTime) : null;
                    t.xpReward = Number(t.xpReward || this.config.baseXpPerTask);
                });
                this.state.userStats.forEach(s => {
                    s.level = Number(s.level || 1);
                    s.xp = Number(s.xp || 0);
                    s.xpToNextLevel = this.calculateXpToNextLevel(s.level);
                });
                this.state.rewardPool.forEach(r => {
                    r.weight = Number(r.weight || 5);
                });
                this.state.generalStats.coins = Number(this.state.generalStats.coins || 0);

                const validTaskIds = new Set(this.state.tasks.map(t => t.id));
                Object.keys(this.state.cardToUseOnNext).forEach(taskId => {
                    if (!validTaskIds.has(taskId)) delete this.state.cardToUseOnNext[taskId];
                });
                this.state.lootboxes = []; // Always start empty (legacy, but will be overwritten if saved lootboxes exist)
            }

            loadLootboxes() {
                try {
                    const saved = localStorage.getItem('habitGameLootboxes');
                    if (saved) {
                        this.state.lootboxes = JSON.parse(saved);
                        console.log('Lootboxes loaded from storage.');
                    } else {
                        this.state.lootboxes = [];
                    }
                } catch (e) {
                    console.warn('Failed to load lootboxes:', e);
                    this.state.lootboxes = [];
                }
            }

            saveLootboxes() {
                try {
                    localStorage.setItem('habitGameLootboxes', JSON.stringify(this.state.lootboxes));
                    console.log('Lootboxes saved.');
                } catch (e) {
                    console.warn('Failed to save lootboxes:', e);
                }
            }
    
            saveState() {
                const stateToSave = {
                    tasks: this.state.tasks,
                    inventory: this.state.inventory,
                    generalStats: this.state.generalStats,
                    userStats: this.state.userStats,
                    activePenalty: this.state.activePenalty,
                    cardToUseOnNext: this.state.cardToUseOnNext,
                    rewardPool: this.state.rewardPool
                };
                try {
                    localStorage.setItem('habitGameState_v2', JSON.stringify(stateToSave));
                    console.log("State saved.");
                } catch (e) {
                     console.error("Failed to save state:", e);
                     alert("Error saving game progress! Local storage might be full or disabled.");
                }
            }

            // --- Stat Management ---
            addStat() {
                const name = this.dom.newStatName.value.trim();
                if (!name) { alert('Please enter a name for the stat.'); return; }
                if (this.state.userStats.some(stat => stat.name.toLowerCase() === name.toLowerCase())) {
                    alert('A stat with this name already exists.'); return;
                }
                const newStat = {
                    id: `stat_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                    name: name, level: 1, xp: 0, xpToNextLevel: this.calculateXpToNextLevel(1)
                };
                this.state.userStats.push(newStat);
                this.dom.newStatName.value = '';
                this.saveState(); this.render();
            }
            deleteStat(statId) {
                const statIndex = this.state.userStats.findIndex(s => s.id === statId);
                if (statIndex === -1) return;
                const statName = this.state.userStats[statIndex].name;
                if (confirm(`Delete stat "${statName}"? Tasks linked to it lose XP association.`)) {
                    this.state.userStats.splice(statIndex, 1);
                    this.state.tasks.forEach(task => { if (task.statId === statId) task.statId = null; });
                    this.saveState(); this.render();
                }
            }
            calculateXpToNextLevel(level) {
                 return Math.floor(this.config.statBaseXpForLevel2 * Math.pow(this.config.statXpLevelMultiplier, level - 1));
            }
            addXpToStat(statId, amount) {
                if (!statId || amount <= 0) return;
                const stat = this.state.userStats.find(s => s.id === statId);
                if (!stat) { console.warn(`Stat ID not found: ${statId}`); return; }
                stat.xp += amount;
                let leveledUp = false;
                while (stat.xp >= stat.xpToNextLevel) {
                    stat.xp -= stat.xpToNextLevel; stat.level++;
                    stat.xpToNextLevel = this.calculateXpToNextLevel(stat.level);
                    leveledUp = true;
                    // Consider a less intrusive notification system later
                    alert(`${stat.name} reached Level ${stat.level}!`);
                }
                // Save state regardless of level up, as XP changed
                this.saveState();
                // Render only if necessary
                if (leveledUp) this.renderUserStats();
                else this.renderSpecificUserStat(statId); // Update just the one stat bar/text
            }

             // --- Task Management ---
            addTask() {
                const name = this.dom.newTaskName.value.trim();
                const baseTimeInput = this.dom.newTaskTime.value;
                const selectedStatId = this.dom.newTaskStat.value || null;
                const description = this.dom.newTaskDesc.value.trim();
                const xpInput = this.dom.newTaskXp.value;

                if (!name || !baseTimeInput) { alert('Task name and time are required.'); return; }
                const baseTime = parseInt(baseTimeInput, 10);
                if (isNaN(baseTime) || baseTime < 10) { alert('Minimum time is 10 seconds.'); return; }
                const xpReward = parseInt(xpInput, 10);

                const newTask = {
                    id: `task_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                    name, description, baseTime,
                    xpReward: isNaN(xpReward) || xpReward < 0 ? this.config.baseXpPerTask : xpReward,
                    bestTime: null, statId: selectedStatId
                };
                this.state.tasks.push(newTask);
                this.dom.newTaskName.value = ''; this.dom.newTaskTime.value = '';
                this.dom.newTaskStat.value = ''; this.dom.newTaskDesc.value = ''; this.dom.newTaskXp.value = '';
                this.dom.addTaskPopup.classList.add('hidden');
                this.saveState(); this.render();
            }
            deleteTask(taskId) {
                if (this.state.activeTask && this.state.activeTask.taskId === taskId) {
                    alert("Cannot delete a running task!"); return;
                }
                const taskIndex = this.state.tasks.findIndex(task => task.id === taskId);
                if (taskIndex === -1) return;
                const taskName = this.state.tasks[taskIndex].name;
                if (confirm(`Delete task "${taskName}"?`)) {
                    this.state.tasks.splice(taskIndex, 1);
                    delete this.state.cardToUseOnNext[taskId];
                    this.saveState();
                    // Only render the tasks list for efficiency? Or full render? Full render safer.
                    this.render();
                }
            }
            selectCardForTask(cardId, taskId) {
                 const card = this.state.inventory.find(c => c.id === cardId);
                 const task = this.state.tasks.find(t => t.id === taskId);
                 if (!card || !task || card.type === 'LOOTBOX_REWARD') {
                     console.warn("Cannot select card/task:", card, task);
                     return; // Invalid selection
                 }
                 // Unselect card if it was selected for another task
                 Object.keys(this.state.cardToUseOnNext).forEach(key => {
                    if(this.state.cardToUseOnNext[key] === cardId) {
                        delete this.state.cardToUseOnNext[key];
                    }
                 });
                 // Select card for this task
                 this.state.cardToUseOnNext[taskId] = cardId;
                 this.renderInventory(false); // Re-render inventory to show selection
                 this.renderTasks(false); // Re-render tasks to potentially show "(Card Ready)" although we removed that text
                 // No saveState here - selection confirmed when task starts
                 alert(`Card "${card.name}" ready for task "${task.name}". Start the task to use it.`);
            }

            // --- Reward Pool Management ---
            addReward() {
                const name = this.dom.newRewardName.value.trim();
                const weightInput = this.dom.newRewardWeight.value;
                if (!name || !weightInput) { alert('Reward name and pleasurability score required.'); return; }
                const weight = parseInt(weightInput, 10);
                if (isNaN(weight) || weight < 1 || weight > 10) { alert('Pleasurability must be 1-10.'); return; }
                const newReward = {
                    id: `reward_${Date.now()}_${Math.random().toString(16).slice(2)}`, name, weight
                };
                this.state.rewardPool.push(newReward);
                this.dom.newRewardName.value = ''; this.dom.newRewardWeight.value = '';
                this.dom.addRewardPopup.classList.add('hidden');
                this.saveState();
                this.renderRewardPool();
                this.renderStore(); // Clear generated boxes if pool changes
            }
            deleteReward(rewardId) {
                const rewardIndex = this.state.rewardPool.findIndex(r => r.id === rewardId);
                if (rewardIndex === -1) return;
                const rewardName = this.state.rewardPool[rewardIndex].name;
                if (confirm(`Remove "${rewardName}" from the reward pool?`)) {
                    this.state.rewardPool.splice(rewardIndex, 1);
                    this.saveState();
                    this.renderRewardPool();
                    this.renderStore(); // Clear generated boxes
                }
            }
            renderRewardPool() {
                this.dom.rewardPoolList.innerHTML = '';
                const poolSize = this.state.rewardPool.length;
                const rewardsPerBox = this.config.rewardsPerLootbox;

                if (poolSize === 0) {
                    this.dom.rewardPoolList.innerHTML = '<li style="justify-content: center; color: var(--text-secondary); font-style: italic;">Add rewards to the pool.</li>';
                    this.dom.rewardPoolStatus.textContent = 'Pool empty. Add rewards.';
                    this.dom.generateLootboxesBtn.disabled = true;
                    return;
                }
                const sortedRewards = [...this.state.rewardPool].sort((a,b) => a.name.localeCompare(b.name));
                sortedRewards.forEach(reward => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>${reward.name} (Pleasure: ${reward.weight})</span>
                        <button class="delete delete-reward-btn" data-reward-id="${reward.id}" title="Remove Reward">√ó</button>
                    `;
                    this.dom.rewardPoolList.appendChild(li);
                });

                const isValidSize = poolSize > 0 && poolSize % rewardsPerBox === 0;
                this.dom.generateLootboxesBtn.disabled = !isValidSize;
                if (isValidSize) {
                    this.dom.rewardPoolStatus.textContent = `Pool size: ${poolSize} (Valid for generation - Multiple of ${rewardsPerBox}).`;
                } else {
                    const remainder = poolSize % rewardsPerBox;
                    const neededToAdd = rewardsPerBox - remainder;
                    this.dom.rewardPoolStatus.textContent = `Pool size: ${poolSize}. Need ${neededToAdd} more for a multiple of ${rewardsPerBox}.`;
                }
            }

            // --- Lootbox Generation & Store ---
            generateLootboxes() {
                 const poolSize = this.state.rewardPool.length;
                 const rewardsPerBox = this.config.rewardsPerLootbox;
                 const numBoxes = this.config.numberOfLootboxes;
                 const requiredSize = numBoxes * rewardsPerBox;

                 if (poolSize === 0 || poolSize % rewardsPerBox !== 0) {
                     alert(`Reward pool size (${poolSize}) must be a multiple of ${rewardsPerBox}.`);
                     return;
                 }
                 if (poolSize < requiredSize) {
                     alert(`Need at least ${requiredSize} rewards for ${numBoxes} boxes of ${rewardsPerBox}. Current: ${poolSize}.`);
                     return;
                 }

                this.state.lootboxes = [];
                const rewardsCopy = [...this.state.rewardPool];
                const n = this.config.lootboxBasePrice;

                for (let i = 0; i < numBoxes; i++) {
                    const lootboxRewards = [];
                    if (rewardsCopy.length < rewardsPerBox) break; // Safeguard

                    for (let j = 0; j < rewardsPerBox; j++) {
                        const randomIndex = Math.floor(Math.random() * rewardsCopy.length);
                        lootboxRewards.push(rewardsCopy.splice(randomIndex, 1)[0]);
                    }
                    let price = (i === 0) ? n : (i === 1) ? n * 2 : (n * 2) * 2; // 100, 200, 400
                    this.state.lootboxes.push({
                        id: `lootbox_${i}_${Date.now()}`, name: `Lootbox ${i + 1}`, price, rewards: lootboxRewards
                    });
                }
                console.log("Generated Lootboxes:", this.state.lootboxes);
                this.saveLootboxes();
                this.renderStore();
                alert(`${numBoxes} lootboxes generated!`);
            }
            renderStore() {
                this.dom.lootboxList.innerHTML = '';
                if (this.state.lootboxes.length === 0) {
                    this.dom.lootboxList.innerHTML = '<p>No lootboxes generated. Add rewards (multiple of 3) and generate.</p>';
                    return;
                }
                this.state.lootboxes.forEach(lootbox => {
                    const div = document.createElement('div');
                    div.classList.add('lootbox-item');
                    div.innerHTML = `
                        <h3>${lootbox.name}</h3>
                        <p>Price: ${lootbox.price} <span title="Coins">ü™ô</span></p>
                        <button class="buy-lootbox-btn" data-lootbox-id="${lootbox.id}">Buy</button>
                    `;
                    this.dom.lootboxList.appendChild(div);
                });
            }
            buyLootbox(lootboxId) {
                 const lootbox = this.state.lootboxes.find(lb => lb.id === lootboxId);
                 if (!lootbox) { alert("Error: Lootbox not found."); return; }
                 if (this.state.generalStats.coins < lootbox.price) {
                     alert(`Not enough coins! Need ${lootbox.price} ü™ô, have ${this.state.generalStats.coins} ü™ô.`); return;
                 }
                 this.state.generalStats.coins -= lootbox.price;
                 this.coinSound.play().catch(()=>{});

                 // Weighted Random Selection (Lower Pleasurability = Higher Chance)
                 let totalInverseWeight = lootbox.rewards.reduce((sum, r) => sum + Math.max(1, 11 - r.weight), 0); // Ensure weight >= 1
                 if (totalInverseWeight <= 0) totalInverseWeight = lootbox.rewards.length; // Fallback

                 let randomRoll = Math.random() * totalInverseWeight;
                 let selectedReward = lootbox.rewards[lootbox.rewards.length - 1]; // Default fallback
                 for (const reward of lootbox.rewards) {
                     const effectiveWeight = Math.max(1, 11 - reward.weight);
                     randomRoll -= effectiveWeight;
                     if (randomRoll <= 0) {
                         selectedReward = reward; break;
                     }
                 }

                 this.openBoxSound.play().catch(()=>{});
                 const newCard = {
                     id: `card_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                     type: 'LOOTBOX_REWARD', name: selectedReward.name, emoji: 'üéÅ',
                     description: `From ${lootbox.name}. Click to Burn.` // Updated description
                 };
                 this.state.inventory.push(newCard);
                 alert(`Opened ${lootbox.name}, received: ${selectedReward.name}!`);
                 this.saveState(); this.render();
             }

            // --- Core Game Logic ---
             startTask(taskId) {
                 if (this.state.activeTask) { alert('Task already running!'); return; }
                 const task = this.state.tasks.find(t => t.id === taskId);
                 if (!task) return;
                 this.timerSound.currentTime = 0; this.timerSound.volume = 0; this.timerSound.play().catch(() => {});
                 let timeLimit = task.baseTime;
                 let cardUsed = null; const cardIdToUse = this.state.cardToUseOnNext[taskId];
                 let activePenaltySnapshot = null;

                 // Apply Active Penalty (if any for next task)
                 if (this.state.activePenalty && this.state.activePenalty.nextTask) {
                    activePenaltySnapshot = {...this.state.activePenalty}; // Snapshot before consuming
                    const penaltyDef = this.penaltyTypes.find(p => p.type === activePenaltySnapshot.type);
                    if (penaltyDef?.effect) {
                        const originalTime = timeLimit;
                        timeLimit = Math.max(10, Math.floor(penaltyDef.effect(timeLimit)));
                        alert(`Penalty Applied: ${activePenaltySnapshot.name}\nTime reduced from ${originalTime}s to ${timeLimit}s`);
                    } else {
                         alert(`Penalty Active: ${activePenaltySnapshot.name}\n${activePenaltySnapshot.description}`); // Acknowledge non-time penalties
                    }
                    this.state.activePenalty = null; // Consume penalty
                 }

                 // Apply Selected Reward Card
                 if (cardIdToUse) {
                     const cardIndex = this.state.inventory.findIndex(c => c.id === cardIdToUse);
                     if (cardIndex > -1) {
                         cardUsed = { ...this.state.inventory[cardIndex] };
                         const cardDef = this.rewardCardTypes.find(ct => ct.type === cardUsed.type);
                         if (cardDef?.effect) { timeLimit = Math.max(10, Math.floor(cardDef.effect(timeLimit))); }
                         this.state.inventory.splice(cardIndex, 1); // Consume card
                         delete this.state.cardToUseOnNext[taskId]; // Clear selection state
                     } else { delete this.state.cardToUseOnNext[taskId]; } // Clear invalid selection
                 }
                 const initialTimeLimitForBar = timeLimit;
                 this.state.activeTask = {
                     taskId: task.id, startTime: Date.now(), timerId: null,
                     timeLimit, initialTimeLimit: initialTimeLimitForBar, cardUsed, activePenaltySnapshot
                 };
                 this.dom.taskRunnerName.textContent = `Running: ${task.name}`;
                 this.runTimer();
                 this.saveState(); this.render(); // Full render to update UI state
             }
             runTimer() {
                 if (!this.state.activeTask) return; const { timerId } = this.state.activeTask; if (timerId) clearInterval(timerId);
                 const intervalId = setInterval(() => {
                     if (!this.state.activeTask) { clearInterval(intervalId); return; } // Task ended/cancelled
                     const { startTime, timeLimit, initialTimeLimit } = this.state.activeTask;
                     const elapsed = (Date.now() - startTime) / 1000; const remaining = Math.max(0, timeLimit - elapsed);
                     const progress = initialTimeLimit > 0 ? Math.max(0, Math.min(100, (remaining / initialTimeLimit) * 100)) : 0;
                     this.updateTimerDisplay(remaining, progress);
                     if (remaining <= 0) { clearInterval(intervalId); this.state.activeTask.timerId = null; this.completeTask(false); } // Time ran out
                 }, 100); // Update 10 times/sec
                 if (this.state.activeTask) this.state.activeTask.timerId = intervalId; else clearInterval(intervalId); // Handle immediate cancellation case
             }
             updateTimerDisplay(remainingSeconds, progressPercent) {
                 const minutes = Math.floor(remainingSeconds / 60); const seconds = Math.floor(remainingSeconds % 60);
                 this.dom.timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                 const fadeDuration = 30; let volume = 0; if (remainingSeconds < fadeDuration) { volume = Math.min(1, Math.max(0, 1 - (remainingSeconds / fadeDuration))); } this.timerSound.volume = volume * 0.4; // Adjusted volume
                 this.dom.timerBar.style.width = `${progressPercent}%`;
                 this.dom.timerBar.style.background = progressPercent < 25 ? 'var(--color-danger)' : progressPercent < 50 ? 'var(--color-warning)' : 'linear-gradient(90deg, var(--color-success) 0%, var(--accent-primary) 100%)';
             }
             completeTask(success) {
                 this.timerSound.pause(); this.timerSound.currentTime = 0;
                 if (success) this.winSound.play().catch(()=>{}); else this.loseSound.play().catch(()=>{});
                 if (!this.state.activeTask) return;
                 const { taskId, startTime, timerId, cardUsed, activePenaltySnapshot } = this.state.activeTask;
                 if (timerId) clearInterval(timerId);
                 const task = this.state.tasks.find(t => t.id === taskId);
                 if (!task) { this.state.activeTask = null; this.saveState(); this.render(); return; } // Task deleted mid-run?

                 const timeTaken = Math.max(0, (Date.now() - startTime) / 1000);
                 let finalCoins = 0; let finalStatXp = 0; let message = '';
                 let penaltyMultiplier = activePenaltySnapshot?.penaltyMultiplier || { coins: 1, xp: 1 };
                 let applyCurseOfDoubt = activePenaltySnapshot?.special === 'curseOfDoubt';
                 let doubleNextPenaltyOnFailure = activePenaltySnapshot?.special === 'doubleTrouble';

                 if (success) {
                     const baseCoins = this.config.baseCoinsPerTask;
                     const baseStatXp = task.xpReward;
                     let coinMultiplier = 1; let xpMultiplier = 1;
                     if (cardUsed) {
                         const cardDef = this.rewardCardTypes.find(ct => ct.type === cardUsed.type);
                         if (cardDef?.multiplier) { coinMultiplier *= (cardDef.multiplier.coins || 1); xpMultiplier *= (cardDef.multiplier.xp || 1); }
                         if (cardDef?.special === 'luckyStreak' && Math.random() < 0.25) { coinMultiplier *= 2; xpMultiplier *= 2; message += "üçÄ Lucky Streak! Rewards doubled!\n"; }
                     }
                     coinMultiplier *= penaltyMultiplier.coins; xpMultiplier *= penaltyMultiplier.xp; // Apply penalty reductions
                     const baseTaskTime = task.baseTime; let tier = 'Bronze'; let bonusCoins = 0; let bonusXp = 0;
                     if (timeTaken < baseTaskTime * 0.5) { tier = 'Gold'; bonusCoins = 20; bonusXp = 30; }
                     else if (timeTaken < baseTaskTime * 0.75) { tier = 'Silver'; bonusCoins = 10; bonusXp = 15; }
                     else { tier = 'Bronze'; bonusCoins = 5; bonusXp = 5; }
                     bonusCoins = Math.floor(bonusCoins * coinMultiplier); bonusXp = Math.floor(bonusXp * xpMultiplier);
                     finalCoins = Math.max(0, Math.floor(baseCoins * coinMultiplier) + bonusCoins); // Ensure non-negative
                     finalStatXp = Math.max(0, Math.floor(baseStatXp * xpMultiplier) + bonusXp); // Ensure non-negative

                     if (applyCurseOfDoubt && Math.random() < 0.25) {
                         finalCoins = 0; finalStatXp = 0; message += "üßø Curse of Doubt! Rewards nullified!\n"; this.loseSound.play().catch(()=>{});
                     }
                     if (finalCoins > 0) this.state.generalStats.coins += finalCoins;
                     if (task.statId && finalStatXp > 0) this.addXpToStat(task.statId, finalStatXp); // addXp handles save/render
                     if (task.bestTime === null || timeTaken < task.bestTime) task.bestTime = timeTaken;
                     if (!(applyCurseOfDoubt && finalCoins === 0 && finalStatXp === 0)) { // Grant card if not cursed
                         this.grantRandomRewardCard(); message += "üé¥ Random reward card gained!\n";
                     }
                     message += `‚úÖ Success! (${tier})\nTime: ${timeTaken.toFixed(1)}s\n+${finalCoins}ü™ô, +${finalStatXp} XP`;
                 } else {
                     message = `‚ùå Failed! Time: ${timeTaken.toFixed(1)}s`;
                     if (cardUsed?.special === 'insurance') { // Check for insurance card type
                         message += '\nüõ°Ô∏è Insurance used: Penalty negated.';
                     } else {
                         const penaltyDescription = this.applyRandomPenalty(taskId, doubleNextPenaltyOnFailure);
                         message += penaltyDescription ? `\nPenalty: ${penaltyDescription}` : "\nNo penalty applied.";
                     }
                 }
                 this.state.activeTask = null;
                 this.saveState(); // Save after all updates
                 this.render(); // Render after all updates
                 alert(message); // Show result summary
             }
             grantRandomRewardCard() {
                 if (this.rewardCardTypes.length === 0) return;
                 const randomCardType = this.rewardCardTypes[Math.floor(Math.random() * this.rewardCardTypes.length)];
                 const newCard = { id: `card_${Date.now()}_${Math.random().toString(16).slice(2)}`, ...randomCardType };
                 this.state.inventory.push(newCard);
                  // Save/render handled by completeTask
             }
             applyRandomPenalty(failedTaskId = null, doubleEffect = false) {
                  const possiblePenalties = this.penaltyTypes;
                  if (possiblePenalties.length === 0) return null;
                  const penalty = { ...possiblePenalties[Math.floor(Math.random() * possiblePenalties.length)] };
                  let appliedDescription = `${penalty.name}! ${penalty.description}`;
                  let effectMultiplier = doubleEffect ? 2 : 1;

                  if (penalty.immediate) {
                      if (penalty.type === 'BAD_BEAT') {
                          const cardsToLose = Math.min(this.state.inventory.length, effectMultiplier);
                          if (cardsToLose > 0) {
                               let lostNames = [];
                               for(let i = 0; i < cardsToLose; i++) {
                                   if (this.state.inventory.length === 0) break; // Stop if somehow inventory empty mid-loop
                                   const removedIndex = Math.floor(Math.random() * this.state.inventory.length);
                                   lostNames.push(this.state.inventory.splice(removedIndex, 1)[0].name);
                               }
                               appliedDescription += ` Lost: ${lostNames.join(', ')}`;
                               if(doubleEffect && cardsToLose > 1) appliedDescription += " (Effect Doubled!)";
                          } else { appliedDescription += ' (Inventory empty).'; }
                          // Save state handled by completeTask caller
                      } else if (penalty.type === 'LET_IT_RIDE' && failedTaskId) {
                           appliedDescription += ' Retrying task immediately.';
                           if(doubleEffect) appliedDescription += " (Double Trouble forced!)";
                           setTimeout(() => { this.startTask(failedTaskId); }, 50);
                           return appliedDescription; // Return now, retry is async
                      }
                  } else if (penalty.nextTask) {
                      if (doubleEffect) {
                          appliedDescription += " (Effect Doubled!)";
                          if(penalty.effect) { // Modify time effects (approximate doubling)
                              if (penalty.type === 'TIME_CRUNCH') penalty.effect = (limit) => limit * 0.56; // 0.75^2
                              else if (penalty.type === 'BEAT_THE_CLOCK') penalty.effect = (limit) => Math.max(10, limit - 30);
                              else if (penalty.type === 'TIME_BOMB') penalty.effect = (limit) => limit * 0.64; // 0.8^2
                          }
                          if(penalty.penaltyMultiplier) { // Modify reward multipliers
                               if(penalty.penaltyMultiplier.coins === 0.5) penalty.penaltyMultiplier.coins = 0.25; // 0.5^2
                               if(penalty.penaltyMultiplier.xp === 0.5) penalty.penaltyMultiplier.xp = 0.25;
                           }
                           if(penalty.type === 'CURSE_OF_DOUBT') penalty.description += " (Now 50% chance!)"; // Modify description, logic in completeTask
                           if(penalty.type === 'DOUBLE_TROUBLE') appliedDescription += " Warning: Stacking double trouble!"; // Just flavor
                      }
                       this.state.activePenalty = penalty;
                       // Save state handled by completeTask caller
                  } else { console.warn("Unhandled penalty type:", penalty.type); return null; }

                  return appliedDescription; // Return description for the alert
             }

            // --- UI Rendering ---
            render() {
                 // console.log("Rendering UI..."); // Reduce console noise
                 const isTaskActive = !!this.state.activeTask;

                 this.renderGeneralStats();
                 this.renderUserStats();
                 this.populateStatDropdown();
                 this.renderTasks(isTaskActive);
                 this.renderInventory(isTaskActive); // Handles direct click rendering
                 this.renderActivePenalty(isTaskActive);
                 this.renderRewardPool();
                 this.renderStore();

                 // Toggle section visibility
                 this.dom.taskManagement.classList.toggle('hidden', isTaskActive);
                 this.dom.inventorySection.classList.toggle('hidden', isTaskActive);
                 this.dom.userStatsSection.classList.toggle('hidden', isTaskActive);
                 this.dom.rewardPoolSection.classList.toggle('hidden', isTaskActive);
                 this.dom.storeSection.classList.toggle('hidden', isTaskActive);
                 this.dom.taskRunner.classList.toggle('hidden', !isTaskActive);

                 if (!isTaskActive) this.updateTimerDisplay(0, 100); // Reset timer display

                 if(isTaskActive) { // Ensure popups are hidden if task starts while open
                    this.dom.addTaskPopup.classList.add('hidden');
                    this.dom.addRewardPopup.classList.add('hidden');
                 }
            }
            renderGeneralStats() { this.dom.generalStatsDisplay.textContent = `Coins: ${this.state.generalStats.coins} ü™ô | Base Stat XP: ${this.config.baseXpPerTask}`; }
            renderUserStats() {
                this.dom.userStatsList.innerHTML = '';
                if (this.state.userStats.length === 0) { this.dom.userStatsList.innerHTML = '<li style="justify-content: center; color: var(--text-secondary); font-style: italic;">No stats created yet.</li>'; return; }
                [...this.state.userStats].sort((a, b) => a.name.localeCompare(b.name))
                                      .forEach(stat => this.appendOrUpdateStatElement(stat));
            }
            renderSpecificUserStat(statId) {
                const stat = this.state.userStats.find(s => s.id === statId); if(stat) this.appendOrUpdateStatElement(stat);
            }
            appendOrUpdateStatElement(stat) {
                let li = this.dom.userStatsList.querySelector(`li[data-stat-id="${stat.id}"]`);
                const xpProgress = stat.xpToNextLevel > 0 ? Math.min(100, Math.round((stat.xp / stat.xpToNextLevel) * 100)) : (stat.level > 1 ? 100 : 0);
                const statDetailsHTML = `<div class="stat-card"><button data-stat-id="${stat.id}" class="delete delete-stat-btn" ${this.state.activeTask ? 'disabled' : ''} title="Delete Stat ${stat.name}">√ó</button><div class="stat-details-container"><div class="stat-level">Lvl ${stat.level}</div><div class="stat-name">${stat.name}</div><div class="stat-xp">(${stat.xp} / ${stat.xpToNextLevel} XP - ${xpProgress}%)</div><div class="xp-bar"><div class="xp-bar-fill" style="width: ${xpProgress}%;"></div></div></div></div>`;
                if (li) { li.innerHTML = statDetailsHTML; const button = li.querySelector('.delete-stat-btn'); if (button) button.disabled = !!this.state.activeTask; }
                else { li = document.createElement('li'); li.dataset.statId = stat.id; li.innerHTML = statDetailsHTML; this.dom.userStatsList.appendChild(li); }
            }
            renderTasks(isTaskActive) {
                this.dom.taskList.innerHTML = '';
                if (this.state.tasks.length === 0) { this.dom.taskList.innerHTML = '<li style="justify-content: center; color: var(--text-secondary); font-style: italic;">No tasks added yet.</li>'; return; }
                [...this.state.tasks].sort((a, b) => a.name.localeCompare(b.name))
                                    .forEach(task => {
                    const li = document.createElement('li'); li.dataset.taskId = task.id;
                    const linkedStat = task.statId ? this.state.userStats.find(s => s.id === task.statId) : null;
                    const linkedStatName = linkedStat ? ` | Stat: ${linkedStat.name}` : '';
                    // Removed cardReadyText as it's shown on the card now
                    const bestTimeText = task.bestTime ? `Best: ${task.bestTime.toFixed(1)}s` : 'No best time';
                    const descText = task.description ? `<div class="task-desc">${task.description}</div>` : '';
                    li.innerHTML = `<div class="task-card-content"><div class="task-info"><div class="task-name">${task.name}</div><div class="task-time">Time: ${task.baseTime}s | ${bestTimeText}${linkedStatName}</div>${descText}</div><div class="task-actions"><button data-task-id="${task.id}" class="delete delete-task-btn" ${isTaskActive ? 'disabled' : ''} title="Delete Task">‚úñ</button><button data-task-id="${task.id}" class="start-task-btn" ${isTaskActive ? 'disabled' : ''} title="Start Task">‚ñ∂</button></div></div>`;
                    this.dom.taskList.appendChild(li);
                });
            }
            populateStatDropdown() {
                const select = this.dom.newTaskStat; const currentVal = select.value;
                while (select.options.length > 1) { select.remove(1); } select.options[0].textContent = "None";
                [...this.state.userStats].sort((a, b) => a.name.localeCompare(b.name))
                                        .forEach(stat => { const option = document.createElement('option'); option.value = stat.id; option.textContent = stat.name; select.appendChild(option); });
                select.value = Array.from(select.options).some(opt => opt.value === currentVal) ? currentVal : "";
            }
            renderInventory(isTaskActive) { // UPDATED for Direct Click Interaction
                this.dom.inventoryList.innerHTML = '';
                if (this.state.inventory.length === 0) {
                    this.dom.inventoryEmpty.classList.remove('hidden');
                    this.dom.inventoryList.classList.add('hidden'); // Hide UL if empty
                    return;
                }
                this.dom.inventoryEmpty.classList.add('hidden');
                this.dom.inventoryList.classList.remove('hidden'); // Show UL

                const sortedInventory = [...this.state.inventory].sort((a, b) => a.name.localeCompare(b.name));

                sortedInventory.forEach(card => {
                    const li = document.createElement('li');
                    li.dataset.cardId = card.id;
                    li.classList.add('clickable-card'); // For CSS and event handling
                    if (isTaskActive) li.classList.add('disabled');

                    const isLootboxReward = card.type === 'LOOTBOX_REWARD';
                    let emoji = card.emoji || (isLootboxReward ? 'üéÅ' : 'üé¥');
                    const isSelected = Object.values(this.state.cardToUseOnNext).includes(card.id);

                    if (isSelected && !isTaskActive) li.classList.add('selected-for-task');

                    li.innerHTML = `
                        <div class="card-container">
                            <div class="card-icon">${emoji}</div>
                            <div class="card-details">
                                <span class="card-name">${card.name}</span>
                                <em class="card-desc">${card.description}</em>
                            </div>
                            ${isSelected ? '<span class="card-status">Selected</span>' : ''}
                        </div>
                    `;
                    this.dom.inventoryList.appendChild(li);
                });
            }
            handleBurnCard(cardId) {
                 const cardIndex = this.state.inventory.findIndex(c => c.id === cardId);
                 if (cardIndex === -1) return;
                 const cardName = this.state.inventory[cardIndex].name;
                 if (confirm(`Burn the prize: "${cardName}"? Cannot be undone.`)) {
                     this.state.inventory.splice(cardIndex, 1);
                     this.burnSound.play().catch(()=>{});
                     this.saveState();
                     this.renderInventory(!!this.state.activeTask); // Re-render only inventory
                     alert(`"${cardName}" burned.`);
                 }
            }
            renderActivePenalty(isTaskActive) {
                 const shouldShowPenalty = this.state.activePenalty && this.state.activePenalty.nextTask && !isTaskActive;
                 this.dom.activePenaltyDisplay.textContent = shouldShowPenalty ? `Next Task Penalty: ${this.state.activePenalty.description}` : '';
                 this.dom.activePenaltySection.classList.toggle('hidden', !shouldShowPenalty);
            }

            // --- Event Binding ---
            bindEvents() {
                // Popups
                this.dom.showAddTaskPopup.addEventListener('click', () => this.dom.addTaskPopup.classList.toggle('hidden'));
                this.dom.closeAddTaskPopup.addEventListener('click', () => this.dom.addTaskPopup.classList.add('hidden'));
                this.dom.showAddRewardPopup.addEventListener('click', () => this.dom.addRewardPopup.classList.toggle('hidden'));
                this.dom.closeAddRewardPopup.addEventListener('click', () => this.dom.addRewardPopup.classList.add('hidden'));

                // Add Buttons
                this.dom.addTaskBtn.addEventListener('click', () => this.addTask());
                this.dom.addStatBtn.addEventListener('click', () => this.addStat());
                this.dom.addRewardBtn.addEventListener('click', () => this.addReward());

                // Deletion (Delegation)
                this.dom.userStatsList.addEventListener('click', (e) => {
                    const btn = e.target.closest('button.delete-stat-btn');
                    if (btn && !btn.disabled) this.deleteStat(btn.dataset.statId);
                });
                this.dom.rewardPoolList.addEventListener('click', (e) => {
                    const btn = e.target.closest('button.delete-reward-btn');
                    if (btn && !btn.disabled) this.deleteReward(btn.dataset.rewardId);
                });
                this.dom.taskList.addEventListener('click', (e) => {
                    const btn = e.target.closest('button.delete-task-btn');
                    if (btn && !btn.disabled) this.deleteTask(btn.dataset.taskId);
                });

                // Task Starting (Delegation)
                this.dom.taskList.addEventListener('click', (e) => {
                    const btn = e.target.closest('button.start-task-btn');
                    if (btn && !btn.disabled) this.startTask(btn.dataset.taskId);
                });

                // Lootbox Actions
                this.dom.generateLootboxesBtn.addEventListener('click', () => {
                    if(!this.dom.generateLootboxesBtn.disabled) this.generateLootboxes();
                 });
                this.dom.lootboxList.addEventListener('click', (e) => {
                    const btn = e.target.closest('button.buy-lootbox-btn');
                    if (btn && !btn.disabled) this.buyLootbox(btn.dataset.lootboxId);
                });

                // Inventory Card Clicking (Delegation) - REPLACES previous button logic
                 this.dom.inventoryList.addEventListener('click', (event) => {
                    const targetCardElement = event.target.closest('li.clickable-card');
                    if (!targetCardElement || this.state.activeTask || targetCardElement.classList.contains('disabled')) {
                         // console.log("Inventory click ignored."); // Reduce noise
                         return;
                    }
                    const cardId = targetCardElement.dataset.cardId;
                    if (!cardId) return;
                    const card = this.state.inventory.find(c => c.id === cardId);
                    if (!card) return;

                    if (card.type === 'LOOTBOX_REWARD') this.handleBurnCard(cardId);
                    else this.showTaskSelectionModal(cardId); // Use on task
                 });

                // Card Task Selection Modal
                this.dom.cancelCardTaskBtn.addEventListener('click', () => this.dom.cardTaskModal.classList.add('hidden'));
                this.dom.cardTaskModal.addEventListener('click', (e) => { // Close on overlay click
                     if (e.target === this.dom.cardTaskModal) this.dom.cardTaskModal.classList.add('hidden');
                 });

                // Task Runner Buttons
                this.dom.completeTaskEarlyBtn.addEventListener('click', () => { if (this.state.activeTask) this.completeTask(true); });
                this.dom.failTaskBtn.addEventListener('click', () => { if (this.state.activeTask && confirm('Manually fail task? Penalties apply.')) this.completeTask(false); });

                 // Hover sound for inventory cards
                 this.dom.inventoryList.addEventListener('mouseover', (event) => {
                     const cardElement = event.target.closest('li.clickable-card');
                     if (cardElement && !cardElement.classList.contains('disabled') && this.dom.inventoryList.contains(cardElement)) {
                         this.hoverSound.currentTime = 0; this.hoverSound.play().catch(()=>{});
                     }
                 });
            }

            // Helper for showing task selection modal
            showTaskSelectionModal(cardId) {
                const card = this.state.inventory.find(c => c.id === cardId);
                 if (!card || card.type === 'LOOTBOX_REWARD') { alert("This card type cannot be used on tasks."); return; }
                 if (this.state.tasks.length === 0) { alert("Add a task first!"); return; }

                 const modal = this.dom.cardTaskModal;
                 const taskListDiv = this.dom.cardTaskList;
                 taskListDiv.innerHTML = '';

                 // Add task buttons
                 this.state.tasks.forEach((task) => {
                     const btn = document.createElement('button');
                     btn.textContent = task.name;
                     btn.addEventListener('click', () => {
                         this.selectCardForTask(cardId, task.id);
                         modal.classList.add('hidden');
                     });
                     taskListDiv.appendChild(btn);
                 });

                 // Add unselect button if card is currently selected
                 const currentSelectionTaskId = Object.keys(this.state.cardToUseOnNext).find(taskId => this.state.cardToUseOnNext[taskId] === cardId);
                 if(currentSelectionTaskId) {
                    const taskName = this.state.tasks.find(t=>t.id === currentSelectionTaskId)?.name || 'Unknown Task';
                    const unselectBtn = document.createElement('button');
                    unselectBtn.textContent = `Unselect from: ${taskName}`;
                    unselectBtn.style.background = '#777';
                    unselectBtn.style.marginTop = '5px';
                    unselectBtn.addEventListener('click', () => {
                        delete this.state.cardToUseOnNext[currentSelectionTaskId];
                        this.renderInventory(false); // Update UI
                        this.renderTasks(false);
                        modal.classList.add('hidden');
                    });
                    taskListDiv.appendChild(unselectBtn);
                 }

                 modal.classList.remove('hidden'); // Show modal
            }

            // --- Section Visibility Persistence ---
            loadSectionVisibility() {
                try {
                    const saved = localStorage.getItem('habitGameSectionVisibility');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) {
                    console.warn('Failed to load section visibility:', e);
                    return {};
                }
            }

            saveSectionVisibility() {
                try {
                    localStorage.setItem('habitGameSectionVisibility', JSON.stringify(this.sectionVisibility));
                } catch (e) {
                    console.warn('Failed to save section visibility:', e);
                }
            }

            addSectionToggles() {
                const sections = document.querySelectorAll('.section');
                sections.forEach(section => {
                    const header = section.querySelector('h2');
                    const content = section.querySelector('.section-content');
                    if (!header || !content) return;

                    const toggleBtn = document.createElement('button');
                    toggleBtn.textContent = '‚ñº';
                    toggleBtn.style.float = 'right';
                    toggleBtn.style.fontSize = '1em';
                    toggleBtn.style.marginLeft = '10px';
                    toggleBtn.style.background = 'none';
                    toggleBtn.style.border = 'none';
                    toggleBtn.style.cursor = 'pointer';
                    toggleBtn.style.color = 'var(--text-secondary)';

                    const sectionId = section.id;
                    if (this.sectionVisibility[sectionId]) {
                        content.classList.add('hidden');
                        toggleBtn.textContent = '‚ñ∫';
                    }

                    toggleBtn.addEventListener('click', () => {
                        const isHidden = content.classList.toggle('hidden');
                        toggleBtn.textContent = isHidden ? '‚ñ∫' : '‚ñº';
                        this.sectionVisibility[sectionId] = isHidden;
                        this.saveSectionVisibility();
                    });

                    header.appendChild(toggleBtn);
                });
            }
        } // End HabitGame Class

        // Initialize Game on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            try {
                window.habitGame = new HabitGame();
            } catch (error) {
                console.error("Failed to initialize HabitGame:", error);
                document.body.innerHTML = `<div style="color: red; padding: 20px; border: 1px solid red; background: #330000;"><h2>Error Initializing Game</h2><p>There was a critical error and the game could not start. Please check the console (F12) for details.</p><pre>${error.stack || error}</pre></div>`;
            }
        });
    </script>
</body>
</html>
